// CollectorService defines the gRPC interface between route-beacon collectors
// and the central aggregation server. Collectors initiate all connections;
// authentication relies on private-CA mTLS.
//
// Data flow:
//   1. Collector registers itself and its router sessions (Register).
//   2. Collector sends a full route snapshot on connect, then incremental
//      delta updates over a bidirectional stream (SyncRoutes).
//   3. Central pushes diagnostic commands to the collector (SubscribeCommands).
//   4. Collector streams command output back to central (ReportCommandResult).

syntax = "proto3";

package routebeacon.v1;

option go_package = "routebeacon/v1;routebeaconv1";

import "google/protobuf/timestamp.proto";

// ---------------------------------------------------------------------------
// Service
// ---------------------------------------------------------------------------

// CollectorService is the single gRPC service exposed by central.
// Every RPC is initiated by the collector (client); the server never dials
// back, which keeps firewall rules simple and NAT-friendly.
service CollectorService {

  // Register is called once when a collector starts up. It announces the
  // collector's identity and the set of router sessions it manages. Central
  // validates the request and returns an acceptance status.
  rpc Register(RegisterRequest) returns (RegisterResponse);

  // SyncRoutes is a bidirectional stream used for all route data exchange.
  // On initial connect the collector sends a full snapshot bracketed by
  // BeginSnapshot / EndSnapshot messages. After the snapshot completes,
  // the collector sends incremental RouteUpdate messages as BGP changes
  // occur. Central may send back-pressure signals (Throttle) or snapshot
  // acknowledgments on the return channel.
  rpc SyncRoutes(stream RouteMessage) returns (stream SyncControl);

  // SubscribeCommands opens a server-side stream through which central
  // pushes diagnostic commands (ping, traceroute, etc.) to the collector.
  // The collector keeps this stream open for the lifetime of its connection.
  rpc SubscribeCommands(CollectorIdentity) returns (stream DiagnosticCommand);

  // ReportCommandResult is a client-side stream used by the collector to
  // send the output of a diagnostic command back to central. Results arrive
  // as a series of chunks (individual ping replies, traceroute hops) and
  // are terminated by either a CommandComplete or CommandError message.
  rpc ReportCommandResult(stream CommandResultChunk) returns (CommandAck);
}

// ---------------------------------------------------------------------------
// Register
// ---------------------------------------------------------------------------

// RegisterRequest carries everything central needs to know about a collector
// and the BGP router sessions it manages.
message RegisterRequest {
  // Globally unique identifier for this collector instance.
  string collector_id = 1;

  // Human-readable location label (e.g. "Frankfurt, DE" or "dc-fra-01").
  string location_name = 2;

  // The set of BGP sessions this collector monitors.
  repeated RouterSession router_sessions = 3;
}

// RouterSession describes a single BGP session that the collector reads
// routes from (via BMP, a local RIB dump, etc.).
message RouterSession {
  // Opaque identifier unique within this collector.
  string session_id = 1;

  // Human-readable name shown in the looking glass UI.
  string display_name = 2;

  // Autonomous System Number of the peer router.
  uint32 asn = 3;

  // IP address of the BGP neighbor (IPv4 or IPv6, text form).
  string neighbor_address = 4;
}

// RegisterResponse tells the collector whether central accepted its
// registration.
message RegisterResponse {
  // True if the collector was successfully registered.
  bool accepted = 1;

  // Optional human-readable status or rejection reason.
  string message = 2;
}

// ---------------------------------------------------------------------------
// SyncRoutes -- client (collector) messages
// ---------------------------------------------------------------------------

// RouteMessage is the envelope sent by the collector on the SyncRoutes
// stream. Exactly one of the oneof fields is set per message.
message RouteMessage {
  oneof payload {
    // Marks the start of a full RIB snapshot for one router session.
    BeginSnapshot begin_snapshot = 1;

    // Carries one or more route additions or withdrawals.
    RouteUpdate route_update = 2;

    // Marks the end of a full RIB snapshot.
    EndSnapshot end_snapshot = 3;
  }
}

// BeginSnapshot signals that the collector is about to send the complete
// routing table for the given router session. Central should prepare to
// replace any previously held state.
message BeginSnapshot {
  // The router session whose RIB is being transmitted.
  string router_session_id = 1;

  // Wall-clock time at which the snapshot was captured.
  google.protobuf.Timestamp timestamp = 2;
}

// RouteUpdate carries a batch of route changes for a single router session.
// During a snapshot every update is an ADD; after the snapshot, both ADD and
// WITHDRAW actions occur.
message RouteUpdate {
  // The router session this update belongs to.
  string router_session_id = 1;

  // Whether routes in this batch are being announced or withdrawn.
  RouteAction action = 2;

  // One or more routes sharing the same action.
  repeated BGPRoute routes = 3;
}

// RouteAction indicates whether a route is being advertised or removed.
enum RouteAction {
  ROUTE_ACTION_UNSPECIFIED = 0;
  ADD      = 1;
  WITHDRAW = 2;
}

// EndSnapshot tells central that the full RIB dump for a session is
// complete. The route_count field lets central verify it received every
// route.
message EndSnapshot {
  // The router session whose snapshot just finished.
  string router_session_id = 1;

  // Total number of routes the collector sent in this snapshot, used for
  // consistency verification.
  uint32 route_count = 2;
}

// ---------------------------------------------------------------------------
// SyncRoutes -- server (central) messages
// ---------------------------------------------------------------------------

// SyncControl is the envelope sent by central on the SyncRoutes return
// channel. Central uses it either to acknowledge snapshots or to apply
// back-pressure.
message SyncControl {
  oneof payload {
    // Acknowledges successful receipt of a full snapshot.
    SnapshotAck snapshot_ack = 1;

    // Asks the collector to slow down its send rate.
    Throttle throttle = 2;
  }
}

// SnapshotAck confirms that central has ingested a complete snapshot for
// a router session.
message SnapshotAck {
  // The session whose snapshot was acknowledged.
  string router_session_id = 1;

  // Number of routes central actually stored; the collector can compare
  // this against its own count to detect loss.
  uint32 routes_received = 2;
}

// Throttle instructs the collector to pause or slow down sending for the
// given duration. The collector should wait at least delay_ms milliseconds
// before sending the next RouteMessage.
message Throttle {
  // Minimum delay in milliseconds before the next send.
  uint32 delay_ms = 1;
}

// ---------------------------------------------------------------------------
// BGP route and attribute types
// ---------------------------------------------------------------------------

// AddressFamily identifies the IP version of a route prefix.
enum AddressFamily {
  ADDRESS_FAMILY_UNSPECIFIED = 0;
  IPV4 = 1;
  IPV6 = 2;
}

// BGPRoute represents a single entry in the BGP RIB.
message BGPRoute {
  // Network prefix in network byte order (4 bytes for IPv4, 16 for IPv6).
  bytes prefix = 1;

  // CIDR prefix length (0-32 for IPv4, 0-128 for IPv6).
  uint32 prefix_length = 2;

  // Address family of the prefix.
  AddressFamily afi = 3;

  // True if this route is the best path selected by the BGP decision process.
  bool is_best = 4;

  // BGP Add-Path path identifier (RFC 7911). Zero when Add-Path is not in
  // use.
  uint32 path_id = 5;

  // The full set of BGP path attributes for this route.
  BGPAttributes attributes = 6;
}

// BGPAttributes holds the path attributes associated with a BGP route.
message BGPAttributes {
  // Flattened AS_PATH as an ordered list of ASNs (convenience field that
  // expands all segments sequentially).
  repeated uint32 as_path = 1;

  // Structured AS_PATH preserving segment boundaries and types.
  repeated ASPathSegment as_path_segments = 2;

  // Next-hop address in network byte order.
  bytes next_hop = 3;

  // ORIGIN attribute: 0 = IGP, 1 = EGP, 2 = INCOMPLETE.
  uint32 origin = 4;

  // Multi-Exit Discriminator.
  uint32 med = 5;

  // LOCAL_PREF value.
  uint32 local_pref = 6;

  // Standard BGP communities encoded as 32-bit values (RFC 1997).
  // Each value packs the two 16-bit halves: (high << 16) | low.
  repeated uint32 communities = 7;

  // Extended communities as raw 8-byte values (RFC 4360).
  repeated bytes ext_communities = 8;

  // BGP Large Communities (RFC 8092).
  repeated LargeCommunity large_communities = 9;

  // AGGREGATOR attribute: ASN of the aggregating router.
  uint32 aggregator_asn = 10;

  // AGGREGATOR attribute: IP address of the aggregating router in network
  // byte order.
  bytes aggregator_address = 11;

  // ATOMIC_AGGREGATE flag (RFC 4271 section 5.1.6).
  bool atomic_aggregate = 12;

  // Explicit presence flag for MED. In proto3 a zero uint32 is
  // indistinguishable from "field not set", so the sender must set this
  // to true whenever a MED attribute was actually present in the BGP
  // update, even if its value is 0.
  bool med_present = 13;

  // Explicit presence flag for LOCAL_PREF (same rationale as med_present).
  bool local_pref_present = 14;
}

// ASPathSegment represents a single segment of the AS_PATH attribute,
// preserving the distinction between AS_SET and AS_SEQUENCE.
message ASPathSegment {
  // The type of this segment.
  ASPathSegmentType type = 1;

  // ASNs contained in this segment.
  repeated uint32 numbers = 2;
}

// ASPathSegmentType distinguishes ordered sequences from unordered sets
// in the AS_PATH.
enum ASPathSegmentType {
  AS_PATH_SEGMENT_TYPE_UNSPECIFIED = 0;
  AS_SET      = 1;
  AS_SEQUENCE = 2;
}

// LargeCommunity represents a single BGP Large Community (RFC 8092) with
// three 32-bit fields.
message LargeCommunity {
  uint32 global_admin  = 1;
  uint32 local_data_1  = 2;
  uint32 local_data_2  = 3;
}

// ---------------------------------------------------------------------------
// Diagnostic commands (central -> collector)
// ---------------------------------------------------------------------------

// CollectorIdentity identifies the calling collector on the SubscribeCommands
// stream.
message CollectorIdentity {
  // The collector's unique identifier, matching the value sent in Register.
  string collector_id = 1;
}

// DiagnosticCommand is a single command pushed by central for the collector
// to execute against one of its router sessions.
message DiagnosticCommand {
  // Unique identifier for this command invocation, used to correlate results.
  string command_id = 1;

  // The router session that should execute the command.
  string router_session_id = 2;

  // The specific command to run.
  oneof command {
    PingCommand ping = 3;
    TracerouteCommand traceroute = 4;
  }
}

// PingCommand asks the collector to perform an ICMP echo toward a
// destination via the specified router session.
message PingCommand {
  // Target IP address (IPv4 or IPv6 in text form).
  string destination = 1;

  // Number of echo requests to send.
  uint32 count = 2;

  // Per-probe timeout in milliseconds.
  uint32 timeout_ms = 3;
}

// TracerouteCommand asks the collector to trace the path toward a
// destination via the specified router session.
message TracerouteCommand {
  // Target IP address (IPv4 or IPv6 in text form).
  string destination = 1;

  // Maximum number of hops (TTL limit).
  uint32 max_hops = 2;

  // Per-probe timeout in milliseconds.
  uint32 timeout_ms = 3;
}

// ---------------------------------------------------------------------------
// Diagnostic results (collector -> central)
// ---------------------------------------------------------------------------

// CommandResultChunk carries one piece of output from a diagnostic command.
// The collector sends a stream of these, ending with either CommandComplete
// or CommandError.
message CommandResultChunk {
  // The command_id this result belongs to.
  string command_id = 1;

  // Exactly one result type per chunk.
  oneof result {
    // A single ICMP echo reply (or timeout).
    PingResult ping_result = 2;

    // A single traceroute hop.
    TracerouteHop traceroute_hop = 3;

    // Signals successful completion of the command.
    CommandComplete complete = 4;

    // Signals that the command failed.
    CommandError error = 5;
  }
}

// PingResult reports the outcome of a single ICMP echo request.
message PingResult {
  // Sequence number of the echo request (starting from 1).
  uint32 sequence = 1;

  // Round-trip time in microseconds. Meaningful only when success is true.
  uint32 rtt_us = 2;

  // IP TTL of the echo reply.
  uint32 ttl = 3;

  // True if a reply was received before the timeout expired.
  bool success = 4;
}

// TracerouteHop reports the result of probing one TTL value during a
// traceroute.
message TracerouteHop {
  // The TTL / hop number (starting from 1).
  uint32 hop_number = 1;

  // IP address of the responding node (empty string if no response).
  string address = 2;

  // Round-trip times in microseconds for each probe at this hop. Multiple
  // values correspond to multiple probes per TTL (commonly 3).
  repeated uint32 rtt_us = 3;
}

// CommandComplete signals that a diagnostic command finished successfully.
message CommandComplete {
  // Plain-text summary of the results (e.g. "5 packets sent, 5 received,
  // 0% loss, avg RTT 12.3 ms").
  string summary = 1;
}

// CommandError signals that a diagnostic command failed.
message CommandError {
  // Machine-readable error code (e.g. "TIMEOUT", "UNREACHABLE",
  // "SESSION_DOWN").
  string code = 1;

  // Human-readable error description.
  string message = 2;
}

// CommandAck is the final response from central after the collector closes
// the ReportCommandResult stream.
message CommandAck {
  // True if central successfully processed all result chunks.
  bool accepted = 1;
}
