//go:build go1.22

// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for BGPPathOrigin.
const (
	Egp        BGPPathOrigin = "egp"
	Igp        BGPPathOrigin = "igp"
	Incomplete BGPPathOrigin = "incomplete"
)

// Defines values for CollectorStatus.
const (
	CollectorStatusOffline CollectorStatus = "offline"
	CollectorStatusOnline  CollectorStatus = "online"
)

// Defines values for CommunityType.
const (
	Extended CommunityType = "extended"
	Large    CommunityType = "large"
	Standard CommunityType = "standard"
)

// Defines values for HealthResponseStatus.
const (
	Degraded  HealthResponseStatus = "degraded"
	Healthy   HealthResponseStatus = "healthy"
	Unhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for LGTargetStatus.
const (
	Down    LGTargetStatus = "down"
	Unknown LGTargetStatus = "unknown"
	Up      LGTargetStatus = "up"
)

// Defines values for RouteLookupMetaCollectorStatus.
const (
	RouteLookupMetaCollectorStatusOffline RouteLookupMetaCollectorStatus = "offline"
	RouteLookupMetaCollectorStatusOnline  RouteLookupMetaCollectorStatus = "online"
)

// Defines values for RouteLookupMetaMatchType.
const (
	RouteLookupMetaMatchTypeExact   RouteLookupMetaMatchType = "exact"
	RouteLookupMetaMatchTypeLongest RouteLookupMetaMatchType = "longest"
)

// Defines values for LookupRoutesParamsMatchType.
const (
	LookupRoutesParamsMatchTypeExact   LookupRoutesParamsMatchType = "exact"
	LookupRoutesParamsMatchTypeLongest LookupRoutesParamsMatchType = "longest"
)

// BGPPath defines model for BGPPath.
type BGPPath struct {
	// Aggregator Aggregator attribute. Null if not present.
	Aggregator *struct {
		Address *string `json:"address,omitempty"`
		Asn     *int    `json:"asn,omitempty"`
	} `json:"aggregator"`

	// AsPath Ordered list of AS numbers in the path (origin AS last).
	AsPath []int `json:"as_path"`

	// AtomicAggregate Whether the atomic-aggregate attribute is set.
	AtomicAggregate bool `json:"atomic_aggregate"`

	// Best True if this is the best path as exported by the router to the
	// looking glass session.
	Best bool `json:"best"`

	// Filtered Path was denied by an inbound or outbound route policy.
	Filtered bool `json:"filtered"`

	// Stale Path was not refreshed after a graceful restart.
	Stale bool `json:"stale"`

	// Communities Standard BGP communities.
	Communities []Community `json:"communities"`

	// ExtendedCommunities Extended BGP communities (route targets, etc.).
	ExtendedCommunities []Community `json:"extended_communities"`

	// LargeCommunities Large BGP communities (RFC 8092).
	LargeCommunities []Community `json:"large_communities"`

	// LocalPref Local Preference. Null if not present (e.g. eBGP-learned).
	LocalPref *int `json:"local_pref"`

	// Med Multi-Exit Discriminator. Null if not present.
	Med *int `json:"med"`

	// NextHop Next-hop IP address.
	NextHop string `json:"next_hop"`

	// Origin BGP origin attribute.
	Origin BGPPathOrigin `json:"origin"`
}

// BGPPathOrigin BGP origin attribute.
type BGPPathOrigin string

// Collector defines model for Collector.
type Collector struct {
	// Id Unique collector identifier.
	Id string `json:"id"`

	// Location Human-readable location name (e.g. "Frankfurt, DE").
	Location string `json:"location"`

	// RouterCount Number of LG targets (router sessions) at this collector.
	RouterCount int `json:"router_count"`

	// Status Current connection status of the collector.
	Status CollectorStatus `json:"status"`
}

// CollectorStatus Current connection status of the collector.
type CollectorStatus string

// CollectorSummary Abbreviated collector reference embedded in target objects.
type CollectorSummary struct {
	Id       string `json:"id"`
	Location string `json:"location"`
}

// Community defines model for Community.
type Community struct {
	// Type Community encoding type.
	Type CommunityType `json:"type"`

	// Value Human-readable community string.
	// Standard: "ASN:value" (e.g. "64512:100").
	// Extended: "type:admin:assigned" (e.g. "rt:64512:1000").
	// Large: "global:local1:local2" (e.g. "64512:1:2").
	Value string `json:"value"`
}

// CommunityType Community encoding type.
type CommunityType string

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// CollectorCount Total number of registered collectors.
	CollectorCount int `json:"collector_count"`

	// ConnectedCollectors Number of collectors currently connected.
	ConnectedCollectors int `json:"connected_collectors"`

	// Status Overall system health.
	Status HealthResponseStatus `json:"status"`

	// TotalRoutes Sum of routes across all LG targets.
	TotalRoutes int `json:"total_routes"`

	// UptimeSeconds Seconds since the central API process started.
	UptimeSeconds int `json:"uptime_seconds"`
}

// HealthResponseStatus Overall system health.
type HealthResponseStatus string

// LGTarget defines model for LGTarget.
type LGTarget struct {
	// Asn Autonomous System Number of the router.
	Asn int `json:"asn"`

	// Collector Abbreviated collector reference embedded in target objects.
	Collector CollectorSummary `json:"collector"`

	// DisplayName Operator-assigned name (e.g. "Frankfurt Core 1").
	DisplayName string `json:"display_name"`

	// Id Unique LG target identifier.
	Id string `json:"id"`

	// LastUpdate Timestamp of the most recent route data received from this target.
	LastUpdate time.Time `json:"last_update"`

	// Status BGP session status.
	Status LGTargetStatus `json:"status"`
}

// LGTargetStatus BGP session status.
type LGTargetStatus string

// PingRequest defines model for PingRequest.
type PingRequest struct {
	// Count Number of ICMP echo requests to send.
	Count *int `json:"count,omitempty"`

	// Destination IPv4 or IPv6 destination address.
	Destination string `json:"destination"`

	// TimeoutMs Per-packet timeout in milliseconds.
	TimeoutMs *int `json:"timeout_ms,omitempty"`
}

// ProblemDetail defines model for ProblemDetail.
type ProblemDetail struct {
	// Detail Human-readable explanation specific to this occurrence.
	Detail *string `json:"detail,omitempty"`

	// Instance URI reference identifying this specific occurrence.
	Instance *string `json:"instance,omitempty"`

	// Status HTTP status code.
	Status int `json:"status"`

	// Title Short human-readable summary of the problem type.
	Title string `json:"title"`

	// Type A URI reference that identifies the problem type. "about:blank" when
	// no further semantics beyond the status code are needed.
	Type string `json:"type"`
}

// RateLimitError defines model for RateLimitError.
type RateLimitError struct {
	// Detail Human-readable explanation specific to this occurrence.
	Detail *string `json:"detail,omitempty"`

	// Instance URI reference identifying this specific occurrence.
	Instance *string `json:"instance,omitempty"`

	// RetryAfter Seconds the client must wait before the next request.
	RetryAfter int `json:"retry_after"`

	// Status HTTP status code.
	Status int `json:"status"`

	// Title Short human-readable summary of the problem type.
	Title string `json:"title"`

	// Type A URI reference that identifies the problem type. "about:blank" when
	// no further semantics beyond the status code are needed.
	Type string `json:"type"`
}

// RouteLookupMeta defines model for RouteLookupMeta.
type RouteLookupMeta struct {
	// CollectorStatus Current connection status of the collector serving this target.
	CollectorStatus RouteLookupMetaCollectorStatus `json:"collector_status"`

	// DataUpdatedAt Timestamp of the most recent route data update for this target.
	DataUpdatedAt time.Time `json:"data_updated_at"`

	// MatchType The match type that was actually applied.
	MatchType RouteLookupMetaMatchType `json:"match_type"`

	// Stale True if the data may be outdated due to collector disconnection.
	Stale bool `json:"stale"`
}

// RouteLookupMetaCollectorStatus Current connection status of the collector serving this target.
type RouteLookupMetaCollectorStatus string

// RouteLookupMetaMatchType The match type that was actually applied.
type RouteLookupMetaMatchType string

// RouteLookupResponse defines model for RouteLookupResponse.
type RouteLookupResponse struct {
	Meta RouteLookupMeta `json:"meta"`

	// Paths All BGP paths for the matched prefix on this target.
	Paths []BGPPath `json:"paths"`

	// PlainText Pre-formatted plain-text rendering of the results, suitable for copy-to-clipboard.
	PlainText string `json:"plain_text"`

	// Prefix The matched prefix in CIDR notation.
	Prefix string `json:"prefix"`

	// Target Abbreviated target reference embedded in route lookup results.
	Target TargetSummary `json:"target"`
}

// TargetSummary Abbreviated target reference embedded in route lookup results.
type TargetSummary struct {
	Asn         int    `json:"asn"`
	DisplayName string `json:"display_name"`
	Id          string `json:"id"`
}

// TracerouteRequest defines model for TracerouteRequest.
type TracerouteRequest struct {
	// Destination IPv4 or IPv6 destination address.
	Destination string `json:"destination"`

	// MaxHops Maximum number of hops.
	MaxHops *int `json:"max_hops,omitempty"`

	// TimeoutMs Per-hop timeout in milliseconds.
	TimeoutMs *int `json:"timeout_ms,omitempty"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	// Detail Human-readable explanation specific to this occurrence.
	Detail *string `json:"detail,omitempty"`

	// Instance URI reference identifying this specific occurrence.
	Instance      *string `json:"instance,omitempty"`
	InvalidParams []struct {
		// Name Name of the invalid parameter.
		Name string `json:"name"`

		// Reason Why the parameter is invalid.
		Reason string `json:"reason"`
	} `json:"invalid_params"`

	// Status HTTP status code.
	Status int `json:"status"`

	// Title Short human-readable summary of the problem type.
	Title string `json:"title"`

	// Type A URI reference that identifies the problem type. "about:blank" when
	// no further semantics beyond the status code are needed.
	Type string `json:"type"`
}

// TargetId defines model for TargetId.
type TargetId = string

// BadRequest defines model for BadRequest.
type BadRequest = ProblemDetail

// InternalError defines model for InternalError.
type InternalError = ProblemDetail

// NotFound defines model for NotFound.
type NotFound = ProblemDetail

// ServiceUnavailable defines model for ServiceUnavailable.
type ServiceUnavailable = ProblemDetail

// ListTargetsParams defines parameters for ListTargets.
type ListTargetsParams struct {
	// CollectorId Filter targets to those belonging to this collector.
	CollectorId *string `form:"collector_id,omitempty" json:"collector_id,omitempty"`
}

// LookupRoutesParams defines parameters for LookupRoutes.
type LookupRoutesParams struct {
	// Prefix IPv4 or IPv6 prefix in CIDR notation (e.g. `8.8.8.0/24`,
	// `2001:db8::/32`) or a bare IP address for longest-prefix match.
	Prefix string `form:"prefix" json:"prefix"`

	// MatchType Force a specific match type. When omitted the server auto-detects
	// based on whether the input includes a prefix length.
	MatchType *LookupRoutesParamsMatchType `form:"match_type,omitempty" json:"match_type,omitempty"`
}

// LookupRoutesParamsMatchType defines parameters for LookupRoutes.
type LookupRoutesParamsMatchType string

// PingJSONRequestBody defines body for Ping for application/json ContentType.
type PingJSONRequestBody = PingRequest

// TracerouteJSONRequestBody defines body for Traceroute for application/json ContentType.
type TracerouteJSONRequestBody = TracerouteRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all collectors
	// (GET /api/v1/collectors)
	ListCollectors(w http.ResponseWriter, r *http.Request)
	// Health check
	// (GET /api/v1/health)
	GetHealth(w http.ResponseWriter, r *http.Request)
	// List all LG targets
	// (GET /api/v1/targets)
	ListTargets(w http.ResponseWriter, r *http.Request, params ListTargetsParams)
	// Get a single LG target
	// (GET /api/v1/targets/{targetId})
	GetTarget(w http.ResponseWriter, r *http.Request, targetId TargetId)
	// Ping from a collector
	// (POST /api/v1/targets/{targetId}/ping)
	Ping(w http.ResponseWriter, r *http.Request, targetId TargetId)
	// Look up routes for a prefix
	// (GET /api/v1/targets/{targetId}/routes/lookup)
	LookupRoutes(w http.ResponseWriter, r *http.Request, targetId TargetId, params LookupRoutesParams)
	// Traceroute from a collector
	// (POST /api/v1/targets/{targetId}/traceroute)
	Traceroute(w http.ResponseWriter, r *http.Request, targetId TargetId)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListCollectors operation middleware
func (siw *ServerInterfaceWrapper) ListCollectors(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListCollectors(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHealth(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListTargets operation middleware
func (siw *ServerInterfaceWrapper) ListTargets(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListTargetsParams

	// ------------- Optional query parameter "collector_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "collector_id", r.URL.Query(), &params.CollectorId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collector_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListTargets(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTarget operation middleware
func (siw *ServerInterfaceWrapper) GetTarget(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "targetId" -------------
	var targetId TargetId

	err = runtime.BindStyledParameterWithOptions("simple", "targetId", r.PathValue("targetId"), &targetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "targetId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTarget(w, r, targetId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Ping operation middleware
func (siw *ServerInterfaceWrapper) Ping(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "targetId" -------------
	var targetId TargetId

	err = runtime.BindStyledParameterWithOptions("simple", "targetId", r.PathValue("targetId"), &targetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "targetId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Ping(w, r, targetId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LookupRoutes operation middleware
func (siw *ServerInterfaceWrapper) LookupRoutes(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "targetId" -------------
	var targetId TargetId

	err = runtime.BindStyledParameterWithOptions("simple", "targetId", r.PathValue("targetId"), &targetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "targetId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupRoutesParams

	// ------------- Required query parameter "prefix" -------------

	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "prefix"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "prefix", Err: err})
		return
	}

	// ------------- Optional query parameter "match_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "match_type", r.URL.Query(), &params.MatchType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "match_type", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LookupRoutes(w, r, targetId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Traceroute operation middleware
func (siw *ServerInterfaceWrapper) Traceroute(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "targetId" -------------
	var targetId TargetId

	err = runtime.BindStyledParameterWithOptions("simple", "targetId", r.PathValue("targetId"), &targetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "targetId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Traceroute(w, r, targetId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/api/v1/collectors", wrapper.ListCollectors)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/health", wrapper.GetHealth)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/targets", wrapper.ListTargets)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/targets/{targetId}", wrapper.GetTarget)
	m.HandleFunc("POST "+options.BaseURL+"/api/v1/targets/{targetId}/ping", wrapper.Ping)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/targets/{targetId}/routes/lookup", wrapper.LookupRoutes)
	m.HandleFunc("POST "+options.BaseURL+"/api/v1/targets/{targetId}/traceroute", wrapper.Traceroute)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
